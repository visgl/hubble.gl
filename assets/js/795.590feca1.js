"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[795],{7512:(t,e,n)=>{n.d(e,{A:()=>l});var i=n(1660),o=n(7870),r=n(5656),s=n(898),a=n(2671);class l{constructor(t){(0,i.A)(this,"opts",void 0),(0,i.A)(this,"typedArrayManager",void 0),(0,i.A)(this,"indexStarts",[0]),(0,i.A)(this,"vertexStarts",[0]),(0,i.A)(this,"vertexCount",0),(0,i.A)(this,"instanceCount",0),(0,i.A)(this,"attributes",void 0),(0,i.A)(this,"_attributeDefs",void 0),(0,i.A)(this,"data",void 0),(0,i.A)(this,"getGeometry",void 0),(0,i.A)(this,"geometryBuffer",void 0),(0,i.A)(this,"buffers",void 0),(0,i.A)(this,"positionSize",void 0),(0,i.A)(this,"normalize",void 0);const{attributes:e={}}=t;this.typedArrayManager=r.A,this.attributes={},this._attributeDefs=e,this.opts=t,this.updateGeometry(t)}updateGeometry(t){Object.assign(this.opts,t);const{data:e,buffers:n={},getGeometry:i,geometryBuffer:o,positionFormat:r,dataChanged:a,normalize:l=!0}=this.opts;if(this.data=e,this.getGeometry=i,this.positionSize=o&&o.size||("XY"===r?2:3),this.buffers=n,this.normalize=l,o&&((0,s.A)(e.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),l||(n.positions=o)),this.geometryBuffer=n.positions,Array.isArray(a))for(const s of a)this._rebuildGeometry(s);else this._rebuildGeometry()}updatePartialGeometry({startRow:t,endRow:e}){this._rebuildGeometry({startRow:t,endRow:e})}getGeometryFromBuffer(t){const e=t.value||t;return ArrayBuffer.isView(e)?(0,o.I)(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices}):null}_allocate(t,e){const{attributes:n,buffers:i,_attributeDefs:o,typedArrayManager:r}=this;for(const s in o)if(s in i)r.release(n[s]),n[s]=null;else{const i=o[s];i.copy=e,n[s]=r.allocate(n[s],t,i)}}_forEachGeometry(t,e,n){const{data:i,getGeometry:r}=this,{iterable:s,objectInfo:a}=(0,o.X)(i,e,n);for(const o of s){a.index++;t(r?r(o,a):null,a.index)}}_rebuildGeometry(t){if(!this.data)return;let{indexStarts:e,vertexStarts:n,instanceCount:i}=this;const{data:o,geometryBuffer:r}=this,{startRow:s=0,endRow:l=1/0}=t||{},c={};if(t||(e=[0],n=[0]),this.normalize||!r)this._forEachGeometry(((t,e)=>{const i=t&&this.normalizeGeometry(t);c[e]=i,n[e+1]=n[e]+(i?this.getGeometrySize(i):0)}),s,l),i=n[n.length-1];else if(n=o.startIndices,i=n[o.length]||0,ArrayBuffer.isView(r))i=i||r.length/this.positionSize;else if(r instanceof a.A){const t=r.accessor.stride||4*this.positionSize;i=i||r.byteLength/t}else if(r.buffer){const t=r.stride||4*this.positionSize;i=i||r.buffer.byteLength/t}else if(r.value){const t=r.value,e=r.stride/t.BYTES_PER_ELEMENT||this.positionSize;i=i||t.length/e}this._allocate(i,Boolean(t)),this.indexStarts=e,this.vertexStarts=n,this.instanceCount=i;const p={};this._forEachGeometry(((t,o)=>{const r=c[o]||t;p.vertexStart=n[o],p.indexStart=e[o];const s=o<n.length-1?n[o+1]:i;p.geometrySize=s-n[o],p.geometryIndex=o,this.updateGeometryAttributes(r,p)}),s,l),this.vertexCount=e[e.length-1]}}},8469:(t,e,n)=>{n.d(e,{A:()=>x});var i=n(1660),o=n(5489),r=n(9464),s=n(3656),a=n(1597),l=n(7585),c=n(2170),p=n(7512),u=n(516);class d extends p.A{constructor(t){super({...t,attributes:{positions:{size:3,padding:18,initialize:!0,type:t.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}get(t){return this.attributes[t]}getGeometryFromBuffer(t){return this.normalize?super.getGeometryFromBuffer(t):null}normalizeGeometry(t){return this.normalize?function(t,e,n,i){let o;if(Array.isArray(t[0])){const n=t.length*e;o=new Array(n);for(let i=0;i<t.length;i++)for(let n=0;n<e;n++)o[i*e+n]=t[i][n]||0}else o=t;return n?(0,u.Mk)(o,{size:e,gridResolution:n}):i?(0,u.Iy)(o,{size:e}):o}(t,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):t}getGeometrySize(t){if(h(t)){let e=0;for(const n of t)e+=this.getGeometrySize(n);return e}const e=this.getPathLength(t);return e<2?0:this.isClosed(t)?e<3?0:e+2:e}updateGeometryAttributes(t,e){if(0!==e.geometrySize)if(t&&h(t))for(const n of t){const t=this.getGeometrySize(n);e.geometrySize=t,this.updateGeometryAttributes(n,e),e.vertexStart+=t}else this._updateSegmentTypes(t,e),this._updatePositions(t,e)}_updateSegmentTypes(t,e){const n=this.attributes.segmentTypes,i=!!t&&this.isClosed(t),{vertexStart:o,geometrySize:r}=e;n.fill(0,o,o+r),i?(n[o]=4,n[o+r-2]=4):(n[o]+=1,n[o+r-2]+=2),n[o+r-1]=4}_updatePositions(t,e){const{positions:n}=this.attributes;if(!n||!t)return;const{vertexStart:i,geometrySize:o}=e,r=new Array(3);for(let s=i,a=0;a<o;s++,a++)this.getPointOnPath(t,a,r),n[3*s]=r[0],n[3*s+1]=r[1],n[3*s+2]=r[2]}getPathLength(t){return t.length/this.positionSize}getPointOnPath(t,e,n=[]){const{positionSize:i}=this;e*i>=t.length&&(e+=1-t.length/i);const o=e*i;return n[0]=t[o],n[1]=t[o+1],n[2]=3===i&&t[o+2]||0,n}isClosed(t){if(!this.normalize)return Boolean(this.opts.loop);const{positionSize:e}=this,n=t.length-e;return t[0]===t[n]&&t[1]===t[n+1]&&(2===e||t[2]===t[n+2])}}function h(t){return Array.isArray(t[0])}const g=[0,0,0,255],f={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:t=>t.path},getColor:{type:"accessor",value:g},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},v={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class x extends o.A{constructor(...t){super(...t),(0,i.A)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[r.A,s.A]})}get wrapLongitude(){return!1}initializeState(){const t=!0;this.getAttributeManager().addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:v,accessor:"getPath",update:this.calculatePositions,noAlloc:t,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:t},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:v,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:v,defaultValue:g},instancePickingColors:{size:3,type:5121,accessor:(t,{index:e,target:n})=>this.encodePickingColor(t&&t.__source?t.__source.index:e,n)}}),this.setState({pathTesselator:new d({fp64:this.use64bitPositions()})})}updateState(t){super.updateState(t);const{props:e,changeFlags:n}=t,i=this.getAttributeManager();if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPath)){const{pathTesselator:t}=this.state,o=e.data.attributes||{};t.updateGeometry({data:e.data,geometryBuffer:o.getPath,buffers:o,normalize:!e._pathType,loop:"loop"===e._pathType,getGeometry:e.getPath,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:n.dataChanged}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),n.dataChanged||i.invalidateAll()}if(n.extensionsChanged){var o;const{gl:t}=this.context;null===(o=this.state.model)||void 0===o||o.delete(),this.state.model=this._getModel(t),i.invalidateAll()}}getPickingInfo(t){const e=super.getPickingInfo(t),{index:n}=e,{data:i}=this.props;return i[0]&&i[0].__source&&(e.object=i.find((t=>t.__source.index===n))),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let n=0;n<e.length;n++)e[n].__source.index===t&&this._disablePickingIndex(n);else super.disablePickingIndex(t)}draw({uniforms:t}){const{jointRounded:e,capRounded:n,billboard:i,miterLimit:o,widthUnits:r,widthScale:s,widthMinPixels:l,widthMaxPixels:c}=this.props;this.state.model.setUniforms(t).setUniforms({jointType:Number(e),capType:Number(n),billboard:i,widthUnits:a.p5[r],widthScale:s,miterLimit:o,widthMinPixels:l,widthMaxPixels:c}).draw()}_getModel(t){return new l.A(t,{...this.getShaders(),id:this.props.id,geometry:new c.A({drawMode:4,attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0})}calculatePositions(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateSegmentTypes(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("segmentTypes")}}(0,i.A)(x,"defaultProps",f),(0,i.A)(x,"layerName","PathLayer")},5110:(t,e,n)=>{n.d(e,{$q:()=>v,A4:()=>p,Dt:()=>c,S8:()=>h});var i=n(6570),o=n.n(i),r=n(516);const s=r.rJ.CLOCKWISE,a=r.rJ.COUNTER_CLOCKWISE,l={isClosed:!0};function c(t){return"positions"in t?t.positions:t}function p(t){return"holeIndices"in t?t.holeIndices:null}function u(t,e,n,i,o){let s=e;const a=n.length;for(let r=0;r<a;r++)for(let e=0;e<i;e++)t[s++]=n[r][e]||0;if(!function(t){const e=t[0],n=t[t.length-1];return e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]}(n))for(let r=0;r<i;r++)t[s++]=n[0][r]||0;return l.start=e,l.end=s,l.size=i,(0,r.UD)(t,o,l),s}function d(t,e,n,i,o=0,s,a){const c=(s=s||n.length)-o;if(c<=0)return e;let p=e;for(let r=0;r<c;r++)t[p++]=n[o+r];if(!function(t,e,n,i){for(let o=0;o<e;o++)if(t[n+o]!==t[i-e+o])return!1;return!0}(n,i,o,s))for(let r=0;r<i;r++)t[p++]=n[o+r];return l.start=e,l.end=p,l.size=i,(0,r.UD)(t,a,l),p}function h(t,e){!function(t){if(t=t&&t.positions||t,!Array.isArray(t)&&!ArrayBuffer.isView(t))throw new Error("invalid polygon")}(t);const n=[],i=[];if("positions"in t){const{positions:o,holeIndices:r}=t;if(r){let t=0;for(let l=0;l<=r.length;l++)t=d(n,t,o,e,r[l-1],r[l],0===l?s:a),i.push(t);return i.pop(),{positions:n,holeIndices:i}}t=o}if(!function(t){return Array.isArray(t[0])}(t))return d(n,0,t,e,0,n.length,s),n;if(!function(t){return t.length>=1&&t[0].length>=2&&Number.isFinite(t[0][0])}(t)){let o=0;for(const[r,l]of t.entries())o=u(n,o,l,e,0===r?s:a),i.push(o);return i.pop(),{positions:n,holeIndices:i}}return u(n,0,t,e,s),n}function g(t,e,n){const i=t.length/3;let o=0;for(let r=0;r<i;r++){const s=(r+1)%i;o+=t[3*r+e]*t[3*s+n],o-=t[3*s+e]*t[3*r+n]}return Math.abs(o/2)}function f(t,e,n,i){const o=t.length/3;for(let r=0;r<o;r++){const o=3*r,s=t[o+0],a=t[o+1],l=t[o+2];t[o+e]=s,t[o+n]=a,t[o+i]=l}}function v(t,e,n,i){let r=p(t);r&&(r=r.map((t=>t/e)));let s=c(t);const a=i&&3===e;if(n){const t=s.length;s=s.slice();const i=[];for(let o=0;o<t;o+=e){i[0]=s[o],i[1]=s[o+1],a&&(i[2]=s[o+2]);const t=n(i);s[o]=t[0],s[o+1]=t[1],a&&(s[o+2]=t[2])}}if(a){const t=g(s,0,1),e=g(s,0,2),i=g(s,1,2);if(!t&&!e&&!i)return[];t>e&&t>i||(e>i?(n||(s=s.slice()),f(s,0,2,1)):(n||(s=s.slice()),f(s,2,0,1)))}return o()(s,r,e)}},8086:(t,e,n)=>{n.d(e,{A:()=>S});var i=n(1660),o=n(5489),r=n(9464),s=n(2943),a=n(3656),l=n(1597),c=n(7325),p=n(8404),u=n(7585),d=n(2170),h=n(5110),g=n(7512),f=n(516);class v extends g.A{constructor(t){const{fp64:e,IndexType:n=Uint32Array}=t;super({...t,attributes:{positions:{size:3,type:e?Float64Array:Float32Array},vertexValid:{type:Uint8ClampedArray,size:1},indices:{type:n,size:1}}})}get(t){const{attributes:e}=this;return"indices"===t?e.indices&&e.indices.subarray(0,this.vertexCount):e[t]}updateGeometry(t){super.updateGeometry(t);const e=this.buffers.indices;if(e)this.vertexCount=(e.value||e).length;else if(this.data&&!this.getGeometry)throw new Error("missing indices buffer")}normalizeGeometry(t){if(this.normalize){const e=h.S8(t,this.positionSize);return this.opts.resolution?(0,f.wk)(h.Dt(e),h.A4(e),{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0}):this.opts.wrapLongitude?(0,f.Eg)(h.Dt(e),h.A4(e),{size:this.positionSize,maxLatitude:86,edgeTypes:!0}):e}return t}getGeometrySize(t){if(x(t)){let e=0;for(const n of t)e+=this.getGeometrySize(n);return e}return h.Dt(t).length/this.positionSize}getGeometryFromBuffer(t){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(t):null}updateGeometryAttributes(t,e){if(t&&x(t))for(const n of t){const t=this.getGeometrySize(n);e.geometrySize=t,this.updateGeometryAttributes(n,e),e.vertexStart+=t,e.indexStart=this.indexStarts[e.geometryIndex+1]}else this._updateIndices(t,e),this._updatePositions(t,e),this._updateVertexValid(t,e)}_updateIndices(t,{geometryIndex:e,vertexStart:n,indexStart:i}){const{attributes:o,indexStarts:r,typedArrayManager:s}=this;let a=o.indices;if(!a||!t)return;let l=i;const c=h.$q(t,this.positionSize,this.opts.preproject,this.opts.full3d);a=s.allocate(a,i+c.length,{copy:!0});for(let p=0;p<c.length;p++)a[l++]=c[p]+n;r[e+1]=i+c.length,o.indices=a}_updatePositions(t,{vertexStart:e,geometrySize:n}){const{attributes:{positions:i},positionSize:o}=this;if(!i||!t)return;const r=h.Dt(t);for(let s=e,a=0;a<n;s++,a++){const t=r[a*o],e=r[a*o+1],n=o>2?r[a*o+2]:0;i[3*s]=t,i[3*s+1]=e,i[3*s+2]=n}}_updateVertexValid(t,{vertexStart:e,geometrySize:n}){const{positionSize:i}=this,o=this.attributes.vertexValid,r=t&&h.A4(t);if(t&&t.edgeTypes?o.set(t.edgeTypes,e):o.fill(1,e,e+n),r)for(let s=0;s<r.length;s++)o[e+r[s]/i-1]=0;o[e+n-1]=0}}function x(t){return Array.isArray(t)&&t.length>0&&!Number.isFinite(t[0])}const y="\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",m="#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(y,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n"),_="#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(y,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n"),P=[0,0,0,255],L={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",_full3d:!1,elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:t=>t.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:P},getLineColor:{type:"accessor",value:P},material:!0},w={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class S extends o.A{constructor(...t){super(...t),(0,i.A)(this,"state",void 0)}getShaders(t){return super.getShaders({vs:"top"===t?m:_,fs:"#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[r.A,s.K,a.A]})}get wrapLongitude(){return!1}initializeState(){const{gl:t,viewport:e}=this.context;let{coordinateSystem:n}=this.props;const{_full3d:i}=this.props;let o;e.isGeospatial&&n===l.rf.DEFAULT&&(n=l.rf.LNGLAT),n===l.rf.LNGLAT&&(o=i?e.projectPosition.bind(e):e.projectFlat.bind(e)),this.setState({numInstances:0,polygonTesselator:new v({preproject:o,fp64:this.use64bitPositions(),IndexType:!t||(0,c.QN)(t,p.G.ELEMENT_INDEX_UINT32)?Uint32Array:Uint16Array})});const r=this.getAttributeManager(),s=!0;r.remove(["instancePickingColors"]),r.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:s},positions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:w,accessor:"getPolygon",update:this.calculatePositions,noAlloc:s,shaderAttributes:{positions:{vertexOffset:0,divisor:0},instancePositions:{vertexOffset:0,divisor:1},nextPositions:{vertexOffset:1,divisor:1}}},vertexValid:{size:1,divisor:1,type:5121,update:this.calculateVertexValid,noAlloc:s},elevations:{size:1,transition:w,accessor:"getElevation",shaderAttributes:{elevations:{divisor:0},instanceElevations:{divisor:1}}},fillColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:w,accessor:"getFillColor",defaultValue:P,shaderAttributes:{fillColors:{divisor:0},instanceFillColors:{divisor:1}}},lineColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:w,accessor:"getLineColor",defaultValue:P,shaderAttributes:{lineColors:{divisor:0},instanceLineColors:{divisor:1}}},pickingColors:{size:3,type:5121,accessor:(t,{index:e,target:n})=>this.encodePickingColor(t&&t.__source?t.__source.index:e,n),shaderAttributes:{pickingColors:{divisor:0},instancePickingColors:{divisor:1}}}})}getPickingInfo(t){const e=super.getPickingInfo(t),{index:n}=e,{data:i}=this.props;return i[0]&&i[0].__source&&(e.object=i.find((t=>t.__source.index===n))),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let n=0;n<e.length;n++)e[n].__source.index===t&&this._disablePickingIndex(n);else super.disablePickingIndex(t)}draw({uniforms:t}){const{extruded:e,filled:n,wireframe:i,elevationScale:o}=this.props,{topModel:r,sideModel:s,polygonTesselator:a}=this.state,l={...t,extruded:Boolean(e),elevationScale:o};s&&(s.setInstanceCount(a.instanceCount-1),s.setUniforms(l),i&&(s.setDrawMode(3),s.setUniforms({isWireframe:!0}).draw()),n&&(s.setDrawMode(6),s.setUniforms({isWireframe:!1}).draw())),r&&(r.setVertexCount(a.vertexCount),r.setUniforms(l).draw())}updateState(t){super.updateState(t),this.updateGeometry(t);const{props:e,oldProps:n,changeFlags:i}=t,o=this.getAttributeManager();var r;(i.extensionsChanged||e.filled!==n.filled||e.extruded!==n.extruded)&&(null===(r=this.state.models)||void 0===r||r.forEach((t=>t.delete())),this.setState(this._getModels(this.context.gl)),o.invalidateAll())}updateGeometry({props:t,oldProps:e,changeFlags:n}){if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPolygon)){const{polygonTesselator:e}=this.state,i=t.data.attributes||{};e.updateGeometry({data:t.data,normalize:t._normalize,geometryBuffer:i.getPolygon,buffers:i,getGeometry:t.getPolygon,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:n.dataChanged,full3d:t._full3d}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),n.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(t){const{id:e,filled:n,extruded:i}=this.props;let o,r;if(n){const n=this.getShaders("top");n.defines.NON_INSTANCED_MODEL=1,o=new u.A(t,{...n,id:"".concat(e,"-top"),drawMode:4,attributes:{vertexPositions:new Float32Array([0,1])},uniforms:{isWireframe:!1,isSideVertex:!1},vertexCount:0,isIndexed:!0})}return i&&(r=new u.A(t,{...this.getShaders("side"),id:"".concat(e,"-side"),geometry:new d.A({drawMode:1,vertexCount:4,attributes:{vertexPositions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),instanceCount:0,isInstanced:1}),r.userData.excludeAttributes={indices:!0}),{models:[r,o].filter(Boolean),topModel:o,sideModel:r}}calculateIndices(t){const{polygonTesselator:e}=this.state;t.startIndices=e.indexStarts,t.value=e.get("indices")}calculatePositions(t){const{polygonTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateVertexValid(t){t.value=this.state.polygonTesselator.get("vertexValid")}}(0,i.A)(S,"defaultProps",L),(0,i.A)(S,"layerName","SolidPolygonLayer")},3986:(t,e,n)=>{function i({data:t,getIndex:e,dataRange:n,replace:i}){const{startRow:o=0,endRow:r=1/0}=n,s=t.length;let a=s,l=s;for(let u=0;u<s;u++){const n=e(t[u]);if(a>u&&n>=o&&(a=u),n>=r){l=u;break}}let c=a;const p=l-a!==i.length?t.slice(l):void 0;for(let u=0;u<i.length;u++)t[c++]=i[u];if(p){for(let e=0;e<p.length;e++)t[c++]=p[e];t.length=c}return{startRow:a,endRow:a+i.length}}n.d(e,{J:()=>i})},2943:(t,e,n)=>{n.d(e,{K:()=>p,p:()=>u});const i="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",o={lightSources:{}};function r(){let{color:t=[0,0,0],intensity:e=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.map((t=>t*e/255))}const s={name:"lights",vs:i,fs:i,getUniforms:function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:o;if("lightSources"in e){const{ambientLight:t,pointLights:n,directionalLights:i}=e.lightSources||{};return t||n&&n.length>0||i&&i.length>0?Object.assign({},function(t){let{ambientLight:e,pointLights:n=[],directionalLights:i=[]}=t;const o={};return o["lighting_uAmbientLight.color"]=e?r(e):[0,0,0],n.forEach(((t,e)=>{o["lighting_uPointLight[".concat(e,"].color")]=r(t),o["lighting_uPointLight[".concat(e,"].position")]=t.position,o["lighting_uPointLight[".concat(e,"].attenuation")]=t.attenuation||[1,0,0]})),o.lighting_uPointLightCount=n.length,i.forEach(((t,e)=>{o["lighting_uDirectionalLight[".concat(e,"].color")]=r(t),o["lighting_uDirectionalLight[".concat(e,"].direction")]=t.direction})),o.lighting_uDirectionalLightCount=i.length,o}({ambientLight:t,pointLights:n,directionalLights:i}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in e){const n={pointLights:[],directionalLights:[]};for(const t of e.lights||[])switch(t.type){case"ambient":n.ambientLight=t;break;case"directional":n.directionalLights.push(t);break;case"point":n.pointLights.push(t)}return t({lightSources:n})}return{}},defines:{MAX_LIGHTS:3}},a="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",l={};function c(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:l;if(!("material"in t))return{};const{material:e}=t;return e?function(t){const{ambient:e=.35,diffuse:n=.6,shininess:i=32,specularColor:o=[30,30,30]}=t;return{lighting_uAmbient:e,lighting_uDiffuse:n,lighting_uShininess:i,lighting_uSpecularColor:o.map((t=>t/255))}}(e):{lighting_uEnabled:!1}}const p={name:"gouraud-lighting",dependencies:[s],vs:a,defines:{LIGHTING_VERTEX:1},getUniforms:c},u={name:"phong-lighting",dependencies:[s],fs:a,defines:{LIGHTING_FRAGMENT:1},getUniforms:c}},516:(t,e,n)=>{n.d(e,{rJ:()=>i,wk:()=>g,Eg:()=>P,Mk:()=>p,Iy:()=>_,UD:()=>o});const i={CLOCKWISE:1,COUNTER_CLOCKWISE:-1};function o(t,e,n={}){const i=function(t,e={}){return Math.sign(function(t,e={}){const{start:n=0,end:i=t.length}=e,o=e.size||2;let r=0;for(let s=n,a=i-o;s<i;s+=o)r+=(t[s]-t[a])*(t[s+1]+t[a+1]),a=s;return r/2}(t,e))}(t,n);return i!==e&&(function(t,e){const{start:n=0,end:i=t.length,size:o=2}=e,r=(i-n)/o,s=Math.floor(r/2);for(let a=0;a<s;++a){const e=n+a*o,i=n+(r-1-a)*o;for(let n=0;n<o;++n){const o=t[e+n];t[e+n]=t[i+n],t[i+n]=o}}}(t,n),!0)}function r(t,e,n,i,o=[]){let r,s;if(8&n)r=(i[3]-t[1])/(e[1]-t[1]),s=3;else if(4&n)r=(i[1]-t[1])/(e[1]-t[1]),s=1;else if(2&n)r=(i[2]-t[0])/(e[0]-t[0]),s=2;else{if(!(1&n))return null;r=(i[0]-t[0])/(e[0]-t[0]),s=0}for(let a=0;a<t.length;a++)o[a]=(1&s)===a?i[s]:r*(e[a]-t[a])+t[a];return o}function s(t,e){let n=0;return t[0]<e[0]?n|=1:t[0]>e[2]&&(n|=2),t[1]<e[1]?n|=4:t[1]>e[3]&&(n|=8),n}function a(t,e){const n=e.length,i=t.length;if(i>0){let o=!0;for(let r=0;r<n;r++)if(t[i-n+r]!==e[r]){o=!1;break}if(o)return!1}for(let o=0;o<n;o++)t[i+o]=e[o];return!0}function l(t,e){const n=e.length;for(let i=0;i<n;i++)t[i]=e[i]}function c(t,e,n,i,o=[]){const r=i+e*n;for(let s=0;s<n;s++)o[s]=t[r+s];return o}function p(t,e){const{size:n=2,broken:i=!1,gridResolution:o=10,gridOffset:p=[0,0],startIndex:u=0,endIndex:d=t.length}=e||{},h=(d-u)/n;let g=[];const f=[g],y=c(t,0,n,u);let m,_;const P=v(y,o,p,[]),L=[];a(g,y);for(let v=1;v<h;v++){for(m=c(t,v,n,u,m),_=s(m,P);_;){r(y,m,_,P,L);const t=s(L,P);t&&(r(y,L,t,P,L),_=t),a(g,L),l(y,L),x(P,o,_),i&&g.length>n&&(g=[],f.push(g),a(g,y)),_=s(m,P)}a(g,m),l(y,m)}return i?f:f[0]}const u=0,d=1;function h(t,e){for(let n=0;n<e.length;n++)t.push(e[n]);return t}function g(t,e=null,n){if(!t.length)return[];const{size:i=2,gridResolution:o=10,gridOffset:r=[0,0],edgeTypes:a=!1}=n||{},l=[],c=[{pos:t,types:a?new Array(t.length/i).fill(d):null,holes:e||[]}],p=[[],[]];let u=[];for(;c.length;){const{pos:t,types:e,holes:n}=c.shift();y(t,i,n[0]||t.length,p),u=v(p[0],o,r,u);const d=s(p[1],u);if(d){let o=f(t,e,i,0,n[0]||t.length,u,d);const r={pos:o[0].pos,types:o[0].types,holes:[]},s={pos:o[1].pos,types:o[1].types,holes:[]};c.push(r,s);for(let l=0;l<n.length;l++)o=f(t,e,i,n[l],n[l+1]||t.length,u,d),o[0]&&(r.holes.push(r.pos.length),r.pos=h(r.pos,o[0].pos),a&&(r.types=h(r.types,o[0].types))),o[1]&&(s.holes.push(s.pos.length),s.pos=h(s.pos,o[1].pos),a&&(s.types=h(s.types,o[1].types)))}else{const i={positions:t};a&&(i.edgeTypes=e),n.length&&(i.holeIndices=n),l.push(i)}}return l}function f(t,e,n,i,o,s,p){const d=(o-i)/n,h=[],g=[],f=[],v=[],x=[];let y,m,_;const P=c(t,d-1,n,i);let L=Math.sign(8&p?P[1]-s[3]:P[0]-s[2]),w=e&&e[d-1],S=0,C=0;for(let b=0;b<d;b++)y=c(t,b,n,i,y),m=Math.sign(8&p?y[1]-s[3]:y[0]-s[2]),_=e&&e[i/n+b],m&&L&&L!==m&&(r(P,y,p,s,x),a(h,x)&&f.push(w),a(g,x)&&v.push(w)),m<=0?(a(h,y)&&f.push(_),S-=m):f.length&&(f[f.length-1]=u),m>=0?(a(g,y)&&v.push(_),C+=m):v.length&&(v[v.length-1]=u),l(P,y),L=m,w=_;return[S?{pos:h,types:e&&f}:null,C?{pos:g,types:e&&v}:null]}function v(t,e,n,i){const o=Math.floor((t[0]-n[0])/e)*e+n[0],r=Math.floor((t[1]-n[1])/e)*e+n[1];return i[0]=o,i[1]=r,i[2]=o+e,i[3]=r+e,i}function x(t,e,n){8&n?(t[1]+=e,t[3]+=e):4&n?(t[1]-=e,t[3]-=e):2&n?(t[0]+=e,t[2]+=e):1&n&&(t[0]-=e,t[2]-=e)}function y(t,e,n,i){let o=1/0,r=-1/0,s=1/0,a=-1/0;for(let l=0;l<n;l+=e){const e=t[l],n=t[l+1];o=e<o?e:o,r=e>r?e:r,s=n<s?n:s,a=n>a?n:a}return i[0][0]=o,i[0][1]=s,i[1][0]=r,i[1][1]=a,i}const m=85.051129;function _(t,e){const{size:n=2,startIndex:i=0,endIndex:o=t.length,normalize:r=!0}=e||{},s=t.slice(i,o);S(s,n,0,o-i);const a=p(s,{size:n,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(r)for(const l of a)C(l,n);return a}function P(t,e=null,n){const{size:i=2,normalize:o=!0,edgeTypes:r=!1}=n||{};e=e||[];const s=[],a=[];let l=0,c=0;for(let u=0;u<=e.length;u++){const o=e[u]||t.length,r=c,p=L(t,i,l,o);for(let e=p;e<o;e++)s[c++]=t[e];for(let e=l;e<p;e++)s[c++]=t[e];S(s,i,r,c),w(s,i,r,c,null==n?void 0:n.maxLatitude),l=o,a[u]=c}a.pop();const p=g(s,a,{size:i,gridResolution:360,gridOffset:[-180,-180],edgeTypes:r});if(o)for(const u of p)C(u.positions,i);return p}function L(t,e,n,i){let o=-1,r=-1;for(let s=n+1;s<i;s+=e){const e=Math.abs(t[s]);e>o&&(o=e,r=s-1)}return r}function w(t,e,n,i,o=m){const r=t[n],s=t[i-e];if(Math.abs(r-s)>180){const i=c(t,0,e,n);i[0]+=360*Math.round((s-r)/360),a(t,i),i[1]=Math.sign(i[1])*o,a(t,i),i[0]=r,a(t,i)}}function S(t,e,n,i){let o,r=t[0];for(let s=n;s<i;s+=e){o=t[s];const e=o-r;(e>180||e<-180)&&(o-=360*Math.round(e/360)),t[s]=r=o}}function C(t,e){let n;const i=t.length/e;for(let r=0;r<i&&(n=t[r*e],(n+180)%360==0);r++);const o=360*-Math.round(n/360);if(0!==o)for(let r=0;r<i;r++)t[r*e]+=o}},6570:t=>{function e(t,e,i){i=i||2;var r,s,a,l,u,d,g,f=e&&e.length,v=f?e[0]*i:t.length,x=n(t,0,v,i,!0),y=[];if(!x||x.next===x.prev)return y;if(f&&(x=function(t,e,i,o){var r,s,a,l=[];for(r=0,s=e.length;r<s;r++)(a=n(t,e[r]*o,r<s-1?e[r+1]*o:t.length,o,!1))===a.next&&(a.steiner=!0),l.push(h(a));for(l.sort(c),r=0;r<l.length;r++)i=p(l[r],i);return i}(t,e,x,i)),t.length>80*i){r=a=t[0],s=l=t[1];for(var m=i;m<v;m+=i)(u=t[m])<r&&(r=u),(d=t[m+1])<s&&(s=d),u>a&&(a=u),d>l&&(l=d);g=0!==(g=Math.max(a-r,l-s))?32767/g:0}return o(x,y,i,r,s,g,0),y}function n(t,e,n,i,o){var r,s;if(o===b(t,e,n,i)>0)for(r=e;r<n;r+=i)s=w(r,t[r],t[r+1],s);else for(r=n-i;r>=e;r-=i)s=w(r,t[r],t[r+1],s);return s&&x(s,s.next)&&(S(s),s=s.next),s}function i(t,e){if(!t)return t;e||(e=t);var n,i=t;do{if(n=!1,i.steiner||!x(i,i.next)&&0!==v(i.prev,i,i.next))i=i.next;else{if(S(i),(i=e=i.prev)===i.next)break;n=!0}}while(n||i!==e);return e}function o(t,e,n,c,p,u,h){if(t){!h&&u&&function(t,e,n,i){var o=t;do{0===o.z&&(o.z=d(o.x,o.y,e,n,i)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==t);o.prevZ.nextZ=null,o.prevZ=null,function(t){var e,n,i,o,r,s,a,l,c=1;do{for(n=t,t=null,r=null,s=0;n;){for(s++,i=n,a=0,e=0;e<c&&(a++,i=i.nextZ);e++);for(l=c;a>0||l>0&&i;)0!==a&&(0===l||!i||n.z<=i.z)?(o=n,n=n.nextZ,a--):(o=i,i=i.nextZ,l--),r?r.nextZ=o:t=o,o.prevZ=r,r=o;n=i}r.nextZ=null,c*=2}while(s>1)}(o)}(t,c,p,u);for(var g,f,v=t;t.prev!==t.next;)if(g=t.prev,f=t.next,u?s(t,c,p,u):r(t))e.push(g.i/n|0),e.push(t.i/n|0),e.push(f.i/n|0),S(t),t=f.next,v=f.next;else if((t=f)===v){h?1===h?o(t=a(i(t),e,n),e,n,c,p,u,2):2===h&&l(t,e,n,c,p,u):o(i(t),e,n,c,p,u,1);break}}}function r(t){var e=t.prev,n=t,i=t.next;if(v(e,n,i)>=0)return!1;for(var o=e.x,r=n.x,s=i.x,a=e.y,l=n.y,c=i.y,p=o<r?o<s?o:s:r<s?r:s,u=a<l?a<c?a:c:l<c?l:c,d=o>r?o>s?o:s:r>s?r:s,h=a>l?a>c?a:c:l>c?l:c,f=i.next;f!==e;){if(f.x>=p&&f.x<=d&&f.y>=u&&f.y<=h&&g(o,a,r,l,s,c,f.x,f.y)&&v(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function s(t,e,n,i){var o=t.prev,r=t,s=t.next;if(v(o,r,s)>=0)return!1;for(var a=o.x,l=r.x,c=s.x,p=o.y,u=r.y,h=s.y,f=a<l?a<c?a:c:l<c?l:c,x=p<u?p<h?p:h:u<h?u:h,y=a>l?a>c?a:c:l>c?l:c,m=p>u?p>h?p:h:u>h?u:h,_=d(f,x,e,n,i),P=d(y,m,e,n,i),L=t.prevZ,w=t.nextZ;L&&L.z>=_&&w&&w.z<=P;){if(L.x>=f&&L.x<=y&&L.y>=x&&L.y<=m&&L!==o&&L!==s&&g(a,p,l,u,c,h,L.x,L.y)&&v(L.prev,L,L.next)>=0)return!1;if(L=L.prevZ,w.x>=f&&w.x<=y&&w.y>=x&&w.y<=m&&w!==o&&w!==s&&g(a,p,l,u,c,h,w.x,w.y)&&v(w.prev,w,w.next)>=0)return!1;w=w.nextZ}for(;L&&L.z>=_;){if(L.x>=f&&L.x<=y&&L.y>=x&&L.y<=m&&L!==o&&L!==s&&g(a,p,l,u,c,h,L.x,L.y)&&v(L.prev,L,L.next)>=0)return!1;L=L.prevZ}for(;w&&w.z<=P;){if(w.x>=f&&w.x<=y&&w.y>=x&&w.y<=m&&w!==o&&w!==s&&g(a,p,l,u,c,h,w.x,w.y)&&v(w.prev,w,w.next)>=0)return!1;w=w.nextZ}return!0}function a(t,e,n){var o=t;do{var r=o.prev,s=o.next.next;!x(r,s)&&y(r,o,o.next,s)&&P(r,s)&&P(s,r)&&(e.push(r.i/n|0),e.push(o.i/n|0),e.push(s.i/n|0),S(o),S(o.next),o=t=s),o=o.next}while(o!==t);return i(o)}function l(t,e,n,r,s,a){var l=t;do{for(var c=l.next.next;c!==l.prev;){if(l.i!==c.i&&f(l,c)){var p=L(l,c);return l=i(l,l.next),p=i(p,p.next),o(l,e,n,r,s,a,0),void o(p,e,n,r,s,a,0)}c=c.next}l=l.next}while(l!==t)}function c(t,e){return t.x-e.x}function p(t,e){var n=function(t,e){var n,i=e,o=t.x,r=t.y,s=-1/0;do{if(r<=i.y&&r>=i.next.y&&i.next.y!==i.y){var a=i.x+(r-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(a<=o&&a>s&&(s=a,n=i.x<i.next.x?i:i.next,a===o))return n}i=i.next}while(i!==e);if(!n)return null;var l,c=n,p=n.x,d=n.y,h=1/0;i=n;do{o>=i.x&&i.x>=p&&o!==i.x&&g(r<d?o:s,r,p,d,r<d?s:o,r,i.x,i.y)&&(l=Math.abs(r-i.y)/(o-i.x),P(i,t)&&(l<h||l===h&&(i.x>n.x||i.x===n.x&&u(n,i)))&&(n=i,h=l)),i=i.next}while(i!==c);return n}(t,e);if(!n)return e;var o=L(n,t);return i(o,o.next),i(n,n.next)}function u(t,e){return v(t.prev,t,e.prev)<0&&v(e.next,t,t.next)<0}function d(t,e,n,i,o){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*o|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-i)*o|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function h(t){var e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function g(t,e,n,i,o,r,s,a){return(o-s)*(e-a)>=(t-s)*(r-a)&&(t-s)*(i-a)>=(n-s)*(e-a)&&(n-s)*(r-a)>=(o-s)*(i-a)}function f(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&y(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(P(t,e)&&P(e,t)&&function(t,e){var n=t,i=!1,o=(t.x+e.x)/2,r=(t.y+e.y)/2;do{n.y>r!=n.next.y>r&&n.next.y!==n.y&&o<(n.next.x-n.x)*(r-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==t);return i}(t,e)&&(v(t.prev,t,e.prev)||v(t,e.prev,e))||x(t,e)&&v(t.prev,t,t.next)>0&&v(e.prev,e,e.next)>0)}function v(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function x(t,e){return t.x===e.x&&t.y===e.y}function y(t,e,n,i){var o=_(v(t,e,n)),r=_(v(t,e,i)),s=_(v(n,i,t)),a=_(v(n,i,e));return o!==r&&s!==a||(!(0!==o||!m(t,n,e))||(!(0!==r||!m(t,i,e))||(!(0!==s||!m(n,t,i))||!(0!==a||!m(n,e,i)))))}function m(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function _(t){return t>0?1:t<0?-1:0}function P(t,e){return v(t.prev,t,t.next)<0?v(t,e,t.next)>=0&&v(t,t.prev,e)>=0:v(t,e,t.prev)<0||v(t,t.next,e)<0}function L(t,e){var n=new C(t.i,t.x,t.y),i=new C(e.i,e.x,e.y),o=t.next,r=e.prev;return t.next=e,e.prev=t,n.next=o,o.prev=n,i.next=n,n.prev=i,r.next=i,i.prev=r,i}function w(t,e,n,i){var o=new C(t,e,n);return i?(o.next=i.next,o.prev=i,i.next.prev=o,i.next=o):(o.prev=o,o.next=o),o}function S(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function C(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function b(t,e,n,i){for(var o=0,r=e,s=n-i;r<n;r+=i)o+=(t[s]-t[r])*(t[r+1]+t[s+1]),s=r;return o}t.exports=e,t.exports.default=e,e.deviation=function(t,e,n,i){var o=e&&e.length,r=o?e[0]*n:t.length,s=Math.abs(b(t,0,r,n));if(o)for(var a=0,l=e.length;a<l;a++){var c=e[a]*n,p=a<l-1?e[a+1]*n:t.length;s-=Math.abs(b(t,c,p,n))}var u=0;for(a=0;a<i.length;a+=3){var d=i[a]*n,h=i[a+1]*n,g=i[a+2]*n;u+=Math.abs((t[d]-t[g])*(t[h+1]-t[d+1])-(t[d]-t[h])*(t[g+1]-t[d+1]))}return 0===s&&0===u?0:Math.abs((u-s)/s)},e.flatten=function(t){for(var e=t[0][0].length,n={vertices:[],holes:[],dimensions:e},i=0,o=0;o<t.length;o++){for(var r=0;r<t[o].length;r++)for(var s=0;s<e;s++)n.vertices.push(t[o][r][s]);o>0&&(i+=t[o-1].length,n.holes.push(i))}return n}}}]);