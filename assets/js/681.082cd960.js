"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[681],{6090:(e,t,i)=>{i.d(t,{A:()=>b});var n=i(1660),o=i(5489),s=i(9464),a=i(3656),r=i(1597),l=i(6820),c=i(7585),d=i(2170);var g=i(8750),u=i(5759),f=i(7256),h=i(7870);const p=()=>{},v={10241:9987,10240:9729,10242:33071,10243:33071};function m(e,t,i,n){const o=Math.min(i/t.width,n/t.height),s=Math.floor(t.width*o),a=Math.floor(t.height*o);return 1===o?{data:t,width:s,height:a}:(e.canvas.height=a,e.canvas.width=s,e.clearRect(0,0,s,a),e.drawImage(t,0,0,t.width,t.height,0,0,s,a),{data:e.canvas,width:s,height:a})}function x(e){return e&&(e.id||e.url)}function y(e,t,i){for(let n=0;n<t.length;n++){const{icon:o,xOffset:s}=t[n];e[x(o)]={...o,x:s,y:i}}}class _{constructor(e,{onUpdate:t=p,onError:i=p}){(0,n.A)(this,"gl",void 0),(0,n.A)(this,"onUpdate",void 0),(0,n.A)(this,"onError",void 0),(0,n.A)(this,"_loadOptions",null),(0,n.A)(this,"_texture",null),(0,n.A)(this,"_externalTexture",null),(0,n.A)(this,"_mapping",{}),(0,n.A)(this,"_textureParameters",null),(0,n.A)(this,"_pendingCount",0),(0,n.A)(this,"_autoPacking",!1),(0,n.A)(this,"_xOffset",0),(0,n.A)(this,"_yOffset",0),(0,n.A)(this,"_rowHeight",0),(0,n.A)(this,"_buffer",4),(0,n.A)(this,"_canvasWidth",1024),(0,n.A)(this,"_canvasHeight",0),(0,n.A)(this,"_canvas",null),this.gl=e,this.onUpdate=t,this.onError=i}finalize(){var e;null===(e=this._texture)||void 0===e||e.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(e){const t=this._autoPacking?x(e):e;return this._mapping[t]||{}}setProps({loadOptions:e,autoPacking:t,iconAtlas:i,iconMapping:n,textureParameters:o}){var s;(e&&(this._loadOptions=e),void 0!==t&&(this._autoPacking=t),n&&(this._mapping=n),i)&&(null===(s=this._texture)||void 0===s||s.delete(),this._texture=null,this._externalTexture=i);o&&(this._textureParameters=o)}get isLoaded(){return 0===this._pendingCount}packIcons(e,t){if(!this._autoPacking||"undefined"==typeof document)return;const i=Object.values(function(e,t,i){if(!e||!t)return null;i=i||{};const n={},{iterable:o,objectInfo:s}=(0,h.X)(e);for(const a of o){s.index++;const e=t(a,s),o=x(e);if(!e)throw new Error("Icon is missing.");if(!e.url)throw new Error("Icon url is missing.");n[o]||i[o]&&e.url===i[o].url||(n[o]={...e,source:a,sourceIndex:s.index})}return n}(e,t,this._mapping)||{});if(i.length>0){const{mapping:e,xOffset:t,yOffset:n,rowHeight:o,canvasHeight:s}=function({icons:e,buffer:t,mapping:i={},xOffset:n=0,yOffset:o=0,rowHeight:s=0,canvasWidth:a}){let r=[];for(let c=0;c<e.length;c++){const l=e[c];if(!i[x(l)]){const{height:e,width:c}=l;n+c+t>a&&(y(i,r,o),n=0,o=s+o+t,s=0,r=[]),r.push({icon:l,xOffset:n}),n=n+c+t,s=Math.max(s,e)}}return r.length>0&&y(i,r,o),{mapping:i,rowHeight:s,xOffset:n,yOffset:o,canvasWidth:a,canvasHeight:(l=s+o+t,Math.pow(2,Math.ceil(Math.log2(l))))};var l}({icons:i,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=o,this._mapping=e,this._xOffset=t,this._yOffset=n,this._canvasHeight=s,this._texture||(this._texture=new g.A(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:this._textureParameters||v})),this._texture.height!==this._canvasHeight&&(this._texture=function(e,t,i,n){const o=e.width,s=e.height,a=new g.A(e.gl,{width:t,height:i,parameters:n});return(0,u.ob)(e,a,{targetY:0,width:o,height:s}),e.delete(),a}(this._texture,this._canvasWidth,this._canvasHeight,this._textureParameters||v)),this.onUpdate(),this._canvas=this._canvas||document.createElement("canvas"),this._loadIcons(i)}}_loadIcons(e){const t=this._canvas.getContext("2d",{willReadFrequently:!0});for(const i of e)this._pendingCount++,(0,f.H)(i.url,this._loadOptions).then((e=>{const n=x(i),o=this._mapping[n],{x:s,y:a,width:r,height:l}=o,{data:c,width:d,height:g}=m(t,e,r,l);this._texture.setSubImageData({data:c,x:s+(r-d)/2,y:a+(l-g)/2,width:d,height:g}),o.width=d,o.height=g,this._texture.generateMipmap(),this.onUpdate()})).catch((e=>{this.onError({url:i.url,source:i.source,sourceIndex:i.sourceIndex,loadOptions:this._loadOptions,error:e})})).finally((()=>{this._pendingCount--}))}}const P=[0,0,0,255],C={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:e=>e.position},getIcon:{type:"accessor",value:e=>e.icon},getColor:{type:"accessor",value:P},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,optional:!0},textureParameters:{type:"object",ignore:!0}};class b extends o.A{constructor(...e){super(...e),(0,n.A)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n",fs:"#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[s.A,a.A]})}initializeState(){this.state={iconManager:new _(this.context.gl,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})};this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:5121,accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:P},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(e){super.updateState(e);const{props:t,oldProps:i,changeFlags:n}=e,o=this.getAttributeManager(),{iconAtlas:s,iconMapping:a,data:r,getIcon:l,textureParameters:c}=t,{iconManager:d}=this.state,g=s||this.internalState.isAsyncPropLoading("iconAtlas");if(d.setProps({loadOptions:t.loadOptions,autoPacking:!g,iconAtlas:s,iconMapping:g?a:null,textureParameters:c}),g?i.iconMapping!==t.iconMapping&&o.invalidate("getIcon"):(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getIcon))&&d.packIcons(r,l),n.extensionsChanged){var u;const{gl:e}=this.context;null===(u=this.state.model)||void 0===u||u.delete(),this.state.model=this._getModel(e),o.invalidateAll()}}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(e){super.finalizeState(e),this.state.iconManager.finalize()}draw({uniforms:e}){const{sizeScale:t,sizeMinPixels:i,sizeMaxPixels:n,sizeUnits:o,billboard:s,alphaCutoff:a}=this.props,{iconManager:l}=this.state,c=l.getTexture();c&&this.state.model.setUniforms(e).setUniforms({iconsTexture:c,iconsTextureDim:[c.width,c.height],sizeUnits:r.p5[o],sizeScale:t,sizeMinPixels:i,sizeMaxPixels:n,billboard:s,alphaCutoff:a}).draw()}_getModel(e){return new c.A(e,{...this.getShaders(),id:this.props.id,geometry:new d.A({drawMode:6,attributes:{positions:{size:2,value:new Float32Array([-1,-1,-1,1,1,1,1,-1])}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(e){var t;const i=null===(t=this.getCurrentLayer())||void 0===t?void 0:t.props.onIconError;i?i(e):l.A.error(e.error.message)()}getInstanceOffset(e){const{width:t,height:i,anchorX:n=t/2,anchorY:o=i/2}=this.state.iconManager.getIconMapping(e);return[t/2-n,i/2-o]}getInstanceColorMode(e){return this.state.iconManager.getIconMapping(e).mask?1:0}getInstanceIconFrame(e){const{x:t,y:i,width:n,height:o}=this.state.iconManager.getIconMapping(e);return[t,i,n,o]}}(0,n.A)(b,"defaultProps",C),(0,n.A)(b,"layerName","IconLayer")},6510:(e,t,i)=>{i.d(t,{A:()=>u});var n=i(1660),o=i(5489),s=i(9464),a=i(3656),r=i(1597),l=i(7585),c=i(2170);const d=[0,0,0,255],g={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:e=>e.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:d},getLineColor:{type:"accessor",value:d},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class u extends o.A{getShaders(){return super.getShaders({vs:"#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (!filled) {\n    discard;\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[s.A,a.A]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){if(super.updateState(e),e.changeFlags.extensionsChanged){var t;const{gl:e}=this.context;null===(t=this.state.model)||void 0===t||t.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{radiusUnits:t,radiusScale:i,radiusMinPixels:n,radiusMaxPixels:o,stroked:s,filled:a,billboard:l,antialiasing:c,lineWidthUnits:d,lineWidthScale:g,lineWidthMinPixels:u,lineWidthMaxPixels:f}=this.props;this.state.model.setUniforms(e).setUniforms({stroked:s?1:0,filled:a,billboard:l,antialiasing:c,radiusUnits:r.p5[t],radiusScale:i,radiusMinPixels:n,radiusMaxPixels:o,lineWidthUnits:r.p5[d],lineWidthScale:g,lineWidthMinPixels:u,lineWidthMaxPixels:f}).draw()}_getModel(e){return new l.A(e,{...this.getShaders(),id:this.props.id,geometry:new c.A({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0])}}}),isInstanced:!0})}}(0,n.A)(u,"defaultProps",g),(0,n.A)(u,"layerName","ScatterplotLayer")},9510:(e,t,i)=>{i.d(t,{A:()=>B});var n=i(1660),o=i(8411),s=i(6820),a=i(7870),r=i(6090);const l=.75,c=[];class d extends r.A{constructor(...e){super(...e),(0,n.A)(this,"state",void 0)}getShaders(){return{...super.getShaders(),fs:"#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float sdfBuffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n"}}initializeState(){super.initializeState();this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:5121,size:3,accessor:(e,{index:t,target:i})=>this.encodePickingColor(t,i)}})}updateState(e){super.updateState(e);const{props:t,oldProps:i}=e;let{outlineColor:n}=t;n!==i.outlineColor&&(n=n.map((e=>e/255)),n[3]=Number.isFinite(n[3])?n[3]:1,this.setState({outlineColor:n})),!t.sdf&&t.outlineWidth&&s.A.warn("".concat(this.id,": fontSettings.sdf is required to render outline"))()}draw(e){const{sdf:t,smoothing:i,outlineWidth:n}=this.props,{outlineColor:o}=this.state,s=n?Math.max(i,l*(1-n)):-1;if(e.uniforms={...e.uniforms,sdfBuffer:l,outlineBuffer:s,gamma:i,sdf:Boolean(t),outlineColor:o},super.draw(e),t&&n){const{iconManager:e}=this.state;e.getTexture()&&this.state.model.draw({uniforms:{outlineBuffer:l}})}}getInstanceOffset(e){return e?Array.from(e).flatMap((e=>super.getInstanceOffset(e))):c}getInstanceColorMode(e){return 1}getInstanceIconFrame(e){return e?Array.from(e).flatMap((e=>super.getInstanceIconFrame(e))):c}}(0,n.A)(d,"defaultProps",{getIconOffsets:{type:"accessor",value:e=>e.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}}),(0,n.A)(d,"layerName","MultiIconLayer");const g=1e20;class u{constructor({fontSize:e=24,buffer:t=3,radius:i=8,cutoff:n=.25,fontFamily:o="sans-serif",fontWeight:s="normal",fontStyle:a="normal"}={}){this.buffer=t,this.cutoff=n,this.radius=i;const r=this.size=e+4*t,l=this._createCanvas(r),c=this.ctx=l.getContext("2d",{willReadFrequently:!0});c.font=`${a} ${s} ${e}px ${o}`,c.textBaseline="alphabetic",c.textAlign="left",c.fillStyle="black",this.gridOuter=new Float64Array(r*r),this.gridInner=new Float64Array(r*r),this.f=new Float64Array(r),this.z=new Float64Array(r+1),this.v=new Uint16Array(r)}_createCanvas(e){const t=document.createElement("canvas");return t.width=t.height=e,t}draw(e){const{width:t,actualBoundingBoxAscent:i,actualBoundingBoxDescent:n,actualBoundingBoxLeft:o,actualBoundingBoxRight:s}=this.ctx.measureText(e),a=Math.ceil(i),r=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(s-o))),l=Math.min(this.size-this.buffer,a+Math.ceil(n)),c=r+2*this.buffer,d=l+2*this.buffer,u=Math.max(c*d,0),h=new Uint8ClampedArray(u),p={data:h,width:c,height:d,glyphWidth:r,glyphHeight:l,glyphTop:a,glyphLeft:0,glyphAdvance:t};if(0===r||0===l)return p;const{ctx:v,buffer:m,gridInner:x,gridOuter:y}=this;v.clearRect(m,m,r,l),v.fillText(e,m,m+a);const _=v.getImageData(m,m,r,l);y.fill(g,0,u),x.fill(0,0,u);for(let f=0;f<l;f++)for(let e=0;e<r;e++){const t=_.data[4*(f*r+e)+3]/255;if(0===t)continue;const i=(f+m)*c+e+m;if(1===t)y[i]=0,x[i]=g;else{const e=.5-t;y[i]=e>0?e*e:0,x[i]=e<0?e*e:0}}f(y,0,0,c,d,c,this.f,this.v,this.z),f(x,m,m,r,l,c,this.f,this.v,this.z);for(let g=0;g<u;g++){const e=Math.sqrt(y[g])-Math.sqrt(x[g]);h[g]=Math.round(255-255*(e/this.radius+this.cutoff))}return p}}function f(e,t,i,n,o,s,a,r,l){for(let c=t;c<t+n;c++)h(e,i*s+c,s,o,a,r,l);for(let c=i;c<i+o;c++)h(e,c*s+t,1,n,a,r,l)}function h(e,t,i,n,o,s,a){s[0]=0,a[0]=-g,a[1]=g,o[0]=e[t];for(let r=1,l=0,c=0;r<n;r++){o[r]=e[t+r*i];const n=r*r;do{const e=s[l];c=(o[r]-o[e]+n-e*e)/(r-e)/2}while(c<=a[l]&&--l>-1);l++,s[l]=r,a[l]=c,a[l+1]=g}for(let r=0,l=0;r<n;r++){for(;a[l+1]<r;)l++;const n=s[l],c=r-n;e[t+r*i]=o[n]+c*c}}const p=[];function v(e,t,i,n){let o=0;for(let a=t;a<i;a++){var s;o+=(null===(s=n[e[a]])||void 0===s?void 0:s.layoutWidth)||0}return o}function m(e,t,i,n,o,s){let a=t,r=0;for(let l=t;l<i;l++){const t=v(e,l,l+1,o);r+t>n&&(a<l&&s.push(l),a=l,r=0),r+=t}return r}function x(e,t,i,n,o=0,s){void 0===s&&(s=e.length);const a=[];return"break-all"===t?m(e,o,s,i,n,a):function(e,t,i,n,o,s){let a=t,r=t,l=t,c=0;for(let d=t;d<i;d++)if(" "===e[d]?l=d+1:" "!==e[d+1]&&d+1!==i||(l=d+1),l>r){let t=v(e,r,l,o);c+t>n&&(a<r&&(s.push(r),a=r,c=0),t>n&&(t=m(e,r,l,n,o,s),a=s[s.length-1])),r=l,c+=t}}(e,o,s,i,n,a),a}function y(e,t,i,n,o,a){let r=0,l=0;for(let c=t;c<i;c++){const t=e[c],i=n[t];i?(l||(l=i.layoutHeight),o[c]=r+i.layoutWidth/2,r+=i.layoutWidth):(s.A.warn("Missing character: ".concat(t," (").concat(t.codePointAt(0),")"))(),o[c]=r,r+=32)}a[0]=r,a[1]=l}class _{constructor(e=5){(0,n.A)(this,"limit",void 0),(0,n.A)(this,"_cache",{}),(0,n.A)(this,"_order",[]),this.limit=e}get(e){const t=this._cache[e];return t&&(this._deleteOrder(e),this._appendOrder(e)),t}set(e,t){this._cache[e]?(this.delete(e),this._cache[e]=t,this._appendOrder(e)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[e]=t,this._appendOrder(e))}delete(e){this._cache[e]&&(delete this._cache[e],this._deleteOrder(e))}_deleteOrder(e){const t=this._order.indexOf(e);t>=0&&this._order.splice(t,1)}_appendOrder(e){this._order.push(e)}}const P={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:function(){const e=[];for(let t=32;t<128;t++)e.push(String.fromCharCode(t));return e}(),fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12,smoothing:.1};let C=new _(3);function b(e,t){for(let i=0;i<e.length;i++)t.data[4*i+3]=e[i]}function A(e,t,i,n){e.font="".concat(n," ").concat(i,"px ").concat(t),e.fillStyle="#000",e.textBaseline="alphabetic",e.textAlign="left"}class w{constructor(){(0,n.A)(this,"props",{...P}),(0,n.A)(this,"_key",void 0),(0,n.A)(this,"_atlas",void 0)}get texture(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){const{fontSize:e,buffer:t}=this.props;return(1.2*e+2*t)/e}setProps(e={}){Object.assign(this.props,e),this._key=this._getKey();const t=function(e,t){let i;i="string"==typeof t?new Set(Array.from(t)):new Set(t);const n=C.get(e);if(!n)return i;for(const o in n.mapping)i.has(o)&&i.delete(o);return i}(this._key,this.props.characterSet),i=C.get(this._key);if(i&&0===t.size)return void(this._atlas!==i&&(this._atlas=i));const n=this._generateFontAtlas(t,i);this._atlas=n,C.set(this._key,n)}_generateFontAtlas(e,t){const{fontFamily:i,fontWeight:n,fontSize:o,buffer:s,sdf:a,radius:r,cutoff:l}=this.props;let c=t&&t.data;c||(c=document.createElement("canvas"),c.width=1024);const d=c.getContext("2d",{willReadFrequently:!0});A(d,i,o,n);const{mapping:g,canvasHeight:f,xOffset:h,yOffset:p}=function({characterSet:e,getFontWidth:t,fontHeight:i,buffer:n,maxCanvasWidth:o,mapping:s={},xOffset:a=0,yOffset:r=0}){let l=0,c=a;const d=i+2*n;for(const u of e)if(!s[u]){const e=t(u);c+e+2*n>o&&(c=0,l++),s[u]={x:c+n,y:r+l*d+n,width:e,height:d,layoutWidth:e,layoutHeight:i},c+=e+2*n}return{mapping:s,xOffset:c,yOffset:r+l*d,canvasHeight:(g=r+(l+1)*d,Math.pow(2,Math.ceil(Math.log2(g))))};var g}({getFontWidth:e=>d.measureText(e).width,fontHeight:1.2*o,buffer:s,characterSet:e,maxCanvasWidth:1024,...t&&{mapping:t.mapping,xOffset:t.xOffset,yOffset:t.yOffset}});if(c.height!==f){const e=d.getImageData(0,0,c.width,c.height);c.height=f,d.putImageData(e,0,0)}if(A(d,i,o,n),a){const t=new u({fontSize:o,buffer:s,radius:r,cutoff:l,fontFamily:i,fontWeight:"".concat(n)});for(const i of e){const{data:e,width:n,height:s,glyphTop:a}=t.draw(i);g[i].width=n,g[i].layoutOffsetY=.9*o-a;const r=d.createImageData(n,s);b(e,r),d.putImageData(r,g[i].x,g[i].y)}}else for(const u of e)d.fillText(u,g[u].x,g[u].y+s+.9*o);return{xOffset:h,yOffset:p,mapping:g,data:c,width:c.width,height:c.height}}_getKey(){const{fontFamily:e,fontWeight:t,fontSize:i,buffer:n,sdf:o,radius:s,cutoff:a}=this.props;return o?"".concat(e," ").concat(t," ").concat(i," ").concat(n," ").concat(s," ").concat(a):"".concat(e," ").concat(t," ").concat(i," ").concat(n)}}var S=i(5489),z=i(9464),M=i(3656),O=i(1597),L=i(7585),I=i(2170);const F={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:e=>e.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class E extends S.A{constructor(...e){super(...e),(0,n.A)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[z.A,M.A]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){super.updateState(e);const{changeFlags:t}=e;if(t.extensionsChanged){var i;const{gl:e}=this.context;null===(i=this.state.model)||void 0===i||i.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{billboard:t,sizeScale:i,sizeUnits:n,sizeMinPixels:o,sizeMaxPixels:s,getLineWidth:a}=this.props;let{padding:r}=this.props;r.length<4&&(r=[r[0],r[1],r[0],r[1]]),this.state.model.setUniforms(e).setUniforms({billboard:t,stroked:Boolean(a),padding:r,sizeUnits:O.p5[n],sizeScale:i,sizeMinPixels:o,sizeMaxPixels:s}).draw()}_getModel(e){return new L.A(e,{...this.getShaders(),id:this.props.id,geometry:new I.A({drawMode:6,vertexCount:4,attributes:{positions:{size:2,value:new Float32Array([0,0,1,0,1,1,0,1])}}}),isInstanced:!0})}}(0,n.A)(E,"defaultProps",F),(0,n.A)(E,"layerName","TextBackgroundLayer");const R={start:1,middle:0,end:-1},k={top:1,center:0,bottom:-1},T=[0,0,0,255],W={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:T},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:P.characterSet},fontFamily:P.fontFamily,fontWeight:P.fontWeight,lineHeight:1,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:T},fontSettings:{type:"object",value:{},compare:1},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:e=>e.text},getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:T},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class B extends o.A{constructor(...e){super(...e),(0,n.A)(this,"state",void 0),(0,n.A)(this,"getBoundingRect",((e,t)=>{let{size:[i,n]}=this.transformParagraph(e,t);const{fontSize:o}=this.state.fontAtlasManager.props;i/=o,n/=o;const{getTextAnchor:s,getAlignmentBaseline:a}=this.props;return[(R["function"==typeof s?s(e,t):s]-1)*i/2,(k["function"==typeof a?a(e,t):a]-1)*n/2,i,n]})),(0,n.A)(this,"getIconOffsets",((e,t)=>{const{getTextAnchor:i,getAlignmentBaseline:n}=this.props,{x:o,y:s,rowWidth:a,size:[r,l]}=this.transformParagraph(e,t),c=R["function"==typeof i?i(e,t):i],d=k["function"==typeof n?n(e,t):n],g=o.length,u=new Array(2*g);let f=0;for(let h=0;h<g;h++){const e=(1-c)*(r-a[h])/2;u[f++]=(c-1)*r/2+e+o[h],u[f++]=(d-1)*l/2+s[h]}return u}))}initializeState(){this.state={styleVersion:0,fontAtlasManager:new w},this.props.maxWidth>0&&s.A.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")()}updateState(e){const{props:t,oldProps:i,changeFlags:n}=e;(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getText))&&this._updateText();(this._updateFontAtlas()||t.lineHeight!==i.lineHeight||t.wordBreak!==i.wordBreak||t.maxWidth!==i.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo({info:e}){return e.object=e.index>=0?this.props.data[e.index]:null,e}_updateFontAtlas(){const{fontSettings:e,fontFamily:t,fontWeight:i}=this.props,{fontAtlasManager:n,characterSet:o}=this.state,s={...e,characterSet:o,fontFamily:t,fontWeight:i};if(!n.mapping)return n.setProps(s),!0;for(const a in s)if(s[a]!==n.props[a])return n.setProps(s),!0;return!1}_updateText(){var e;const{data:t,characterSet:i}=this.props,n=null===(e=t.attributes)||void 0===e?void 0:e.getText;let o,{getText:s}=this.props,r=t.startIndices;const l="auto"===i&&new Set;if(n&&r){const{texts:e,characterCount:i}=function({value:e,length:t,stride:i,offset:n,startIndices:o,characterSet:s}){const a=e.BYTES_PER_ELEMENT,r=i?i/a:1,l=n?n/a:0,c=o[t]||Math.ceil((e.length-l)/r),d=s&&new Set,g=new Array(t);let u=e;if(r>1||l>0){u=new(0,e.constructor)(c);for(let t=0;t<c;t++)u[t]=e[t*r+l]}for(let f=0;f<t;f++){const e=o[f],t=o[f+1]||c,i=u.subarray(e,t);g[f]=String.fromCodePoint.apply(null,i),d&&i.forEach(d.add,d)}if(d)for(const f of d)s.add(String.fromCodePoint(f));return{texts:g,characterCount:c}}({...ArrayBuffer.isView(n)?{value:n}:n,length:t.length,startIndices:r,characterSet:l});o=i,s=(t,{index:i})=>e[i]}else{const{iterable:e,objectInfo:i}=(0,a.X)(t);r=[0],o=0;for(const t of e){i.index++;const e=Array.from(s(t,i)||"");l&&e.forEach(l.add,l),o+=e.length,r.push(o)}}this.setState({getText:s,startIndices:r,numInstances:o,characterSet:l||i})}transformParagraph(e,t){const{fontAtlasManager:i}=this.state,n=i.mapping,o=this.state.getText,{wordBreak:s,lineHeight:a,maxWidth:r}=this.props;return function(e,t,i,n,o){const s=Array.from(e),a=s.length,r=new Array(a),l=new Array(a),c=new Array(a),d=("break-word"===i||"break-all"===i)&&isFinite(n)&&n>0,g=[0,0],u=[0,0];let f=0,h=0,v=0;for(let _=0;_<=a;_++){const e=s[_];if("\n"!==e&&_!==a||(v=_),v>h){const e=d?x(s,i,n,o,h,v):p;for(let i=0;i<=e.length;i++){const n=0===i?h:e[i-1],a=i<e.length?e[i]:v;y(s,n,a,o,r,u);for(let e=n;e<a;e++){var m;const t=(null===(m=o[s[e]])||void 0===m?void 0:m.layoutOffsetY)||0;l[e]=f+u[1]/2+t,c[e]=u[0]}f+=u[1]*t,g[0]=Math.max(g[0],u[0])}h=v}"\n"===e&&(r[h]=0,l[h]=0,c[h]=0,h++)}return g[1]=f,{x:r,y:l,rowWidth:c,size:g}}(o(e,t)||"",a,s,r*i.props.fontSize,n)}renderLayers(){const{startIndices:e,numInstances:t,getText:i,fontAtlasManager:{scale:n,texture:o,mapping:s},styleVersion:a}=this.state,{data:r,_dataDiff:l,getPosition:c,getColor:g,getSize:u,getAngle:f,getPixelOffset:h,getBackgroundColor:p,getBorderColor:v,getBorderWidth:m,backgroundPadding:x,background:y,billboard:_,fontSettings:C,outlineWidth:b,outlineColor:A,sizeScale:w,sizeUnits:S,sizeMinPixels:z,sizeMaxPixels:M,transitions:O,updateTriggers:L}=this.props,I=this.getSubLayerClass("characters",d),F=this.getSubLayerClass("background",E);return[y&&new F({getFillColor:p,getLineColor:v,getLineWidth:m,padding:x,getPosition:c,getSize:u,getAngle:f,getPixelOffset:h,billboard:_,sizeScale:w,sizeUnits:S,sizeMinPixels:z,sizeMaxPixels:M,transitions:O&&{getPosition:O.getPosition,getAngle:O.getAngle,getSize:O.getSize,getFillColor:O.getBackgroundColor,getLineColor:O.getBorderColor,getLineWidth:O.getBorderWidth,getPixelOffset:O.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:L.getPosition,getAngle:L.getAngle,getSize:L.getSize,getFillColor:L.getBackgroundColor,getLineColor:L.getBorderColor,getLineWidth:L.getBorderWidth,getPixelOffset:L.getPixelOffset,getBoundingRect:{getText:L.getText,getTextAnchor:L.getTextAnchor,getAlignmentBaseline:L.getAlignmentBaseline,styleVersion:a}}}),{data:r.attributes&&r.attributes.background?{length:r.length,attributes:r.attributes.background}:r,_dataDiff:l,autoHighlight:!1,getBoundingRect:this.getBoundingRect}),new I({sdf:C.sdf,smoothing:Number.isFinite(C.smoothing)?C.smoothing:P.smoothing,outlineWidth:b/(C.radius||P.radius),outlineColor:A,iconAtlas:o,iconMapping:s,getPosition:c,getColor:g,getSize:u,getAngle:f,getPixelOffset:h,billboard:_,sizeScale:w*n,sizeUnits:S,sizeMinPixels:z*n,sizeMaxPixels:M*n,transitions:O&&{getPosition:O.getPosition,getAngle:O.getAngle,getColor:O.getColor,getSize:O.getSize,getPixelOffset:O.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{all:L.getText,getPosition:L.getPosition,getAngle:L.getAngle,getColor:L.getColor,getSize:L.getSize,getPixelOffset:L.getPixelOffset,getIconOffsets:{getTextAnchor:L.getTextAnchor,getAlignmentBaseline:L.getAlignmentBaseline,styleVersion:a}}}),{data:r,_dataDiff:l,startIndices:e,numInstances:t,getIconOffsets:this.getIconOffsets,getIcon:i})]}static set fontAtlasCacheLimit(e){!function(e){s.A.assert(Number.isFinite(e)&&e>=3,"Invalid cache limit"),C=new _(e)}(e)}}(0,n.A)(B,"defaultProps",W),(0,n.A)(B,"layerName","TextLayer")},4997:(e,t,i)=>{i.d(t,{A:()=>v});var n=i(6540),o=i(7367);const s="undefined"!=typeof window?n.useLayoutEffect:n.useEffect;function a(e,t){for(;e;){if(e===t)return!0;e=Object.getPrototypeOf(e)}return!1}var r=i(3684),l=i(5489);const c={position:"absolute",zIndex:-1};function d(e,t){if("function"==typeof e)return e(t);if(Array.isArray(e))return e.map((e=>d(e,t)));if(g(e)){if(null===(i=e.props)||void 0===i?void 0:i.mapStyle)return t.style=c,(0,n.cloneElement)(e,t);if(function(e){const t=e.type;return t&&t.deckGLViewProps}(e))return(0,n.cloneElement)(e,t)}var i;return e}function g(e){return e&&"object"==typeof e&&"type"in e||!1}function u(e){if("function"==typeof e)return(0,n.createElement)(r.A,{},e);if(Array.isArray(e))return e.map(u);if(g(e)){if(e.type===n.Fragment)return u(e.props.children);if(a(e.type,r.A))return e}return e}const f={mixBlendMode:null};function h(e){e.redrawReason&&(e.deck._drawLayers(e.redrawReason),e.redrawReason=null)}const p=(0,n.forwardRef)(((e,t)=>{const[i,c]=(0,n.useState)(0),p=(0,n.useRef)({control:null,version:i,forceUpdate:()=>c((e=>e+1))}).current,v=(0,n.useRef)(null),m=(0,n.useRef)(null),x=(0,n.useMemo)((()=>function({children:e,layers:t=[],views:i=null}){const o=[],s=[],c={};return n.Children.forEach(u(e),(e=>{if(g(e)){const t=e.type;if(a(t,l.A)){const i=function(e,t){const i={},n=e.defaultProps||{};for(const o in t)n[o]!==t[o]&&(i[o]=t[o]);return new e(i)}(t,e.props);s.push(i)}else o.push(e);if(a(t,r.A)&&t!==r.A&&e.props.id){const i=new t(e.props);c[i.id]=i}}else e&&o.push(e)})),Object.keys(c).length>0&&(Array.isArray(i)?i.forEach((e=>{c[e.id]=e})):i&&(c[i.id]=i),i=Object.values(c)),{layers:t=s.length>0?[...s,...t]:t,children:o,views:i}}(e)),[e.layers,e.views,e.children]);let y=!0;const _=t=>{var i;return y&&e.viewState?(p.viewStateUpdateRequested=t,null):(p.viewStateUpdateRequested=null,null===(i=e.onViewStateChange)||void 0===i?void 0:i.call(e,t))},P=t=>{var i;y?p.interactionStateUpdateRequested=t:(p.interactionStateUpdateRequested=null,null===(i=e.onInteractionStateChange)||void 0===i||i.call(e,t))},C=(0,n.useMemo)((()=>{const t={...e,style:null,width:"100%",height:"100%",parent:v.current,canvas:m.current,layers:x.layers,views:x.views,onViewStateChange:_,onInteractionStateChange:P};return delete t._customRender,p.deck&&p.deck.setProps(t),t}),[e]);(0,n.useEffect)((()=>{const t=e.Deck||o.A;return p.deck=function(e,t,i){const n=new t({...i,_customRender:t=>{e.redrawReason=t;const i=n.getViewports();e.lastRenderedViewports!==i?e.forceUpdate():h(e)}});return n}(p,t,{...C,parent:v.current,canvas:m.current}),()=>{var e;return null===(e=p.deck)||void 0===e?void 0:e.finalize()}}),[]),s((()=>{h(p);const{viewStateUpdateRequested:e,interactionStateUpdateRequested:t}=p;e&&_(e),t&&P(t)})),(0,n.useImperativeHandle)(t,(()=>function(e){return{get deck(){return e.deck},pickObject:t=>e.deck.pickObject(t),pickMultipleObjects:t=>e.deck.pickMultipleObjects(t),pickObjects:t=>e.deck.pickObjects(t)}}(p)),[]);const b=p.deck&&p.deck.isInitialized?p.deck.getViewports():void 0,{ContextProvider:A,width:w,height:S,id:z,style:M}=e,{containerStyle:O,canvasStyle:L}=(0,n.useMemo)((()=>function({width:e,height:t,style:i}){const n={position:"absolute",zIndex:0,left:0,top:0,width:e,height:t},o={left:0,top:0};if(i)for(const s in i)s in f?o[s]=i[s]:n[s]=i[s];return{containerStyle:n,canvasStyle:o}}({width:w,height:S,style:M})),[w,S,M]);if(!p.viewStateUpdateRequested&&p.lastRenderedViewports===b||p.version!==i){p.lastRenderedViewports=b,p.version=i;const e=function({children:e,deck:t,ContextProvider:i}){const{viewManager:o}=t||{};if(!o||!o.views.length)return[];const s={},l=o.views[0].id;for(const n of e){let e=l,t=n;g(n)&&a(n.type,r.A)&&(e=n.props.id||l,t=n.props.children);const i=o.getViewport(e),c=o.getViewState(e);if(i){c.padding=i.padding;const{x:n,y:o,width:a,height:r}=i;t=d(t,{x:n,y:o,width:a,height:r,viewport:i,viewState:c}),s[e]||(s[e]={viewport:i,children:[]}),s[e].children.push(t)}}return Object.keys(s).map((e=>{const{viewport:o,children:a}=s[e],{x:r,y:l,width:c,height:d}=o,g={position:"absolute",left:r,top:l,width:c,height:d},u="view-".concat(e),f=(0,n.createElement)("div",{key:u,id:u,style:g},...a);if(i){const s={viewport:o,container:t.canvas.offsetParent,eventManager:t.eventManager,onViewStateChange:i=>{i.viewId=e,t._onViewStateChange(i)}};return(0,n.createElement)(i,{key:u,value:s},f)}return f}))}({children:x.children,deck:p.deck,ContextProvider:A}),t=(0,n.createElement)("canvas",{key:"canvas",id:z||"deckgl-overlay",ref:m,style:L});p.control=(0,n.createElement)("div",{id:"".concat(z||"deckgl","-wrapper"),ref:v,style:O},[t,e])}return y=!1,p.control}));p.defaultProps=o.A.defaultProps;const v=p}}]);